#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorC,          leggomyeggo,   tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorBR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorBL,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     motorFL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_2,     motorFR,       tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     motorBELT,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C2_2,     NOTHING,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C4_1,     motorLB,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C4_2,     motorRB,       tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C3_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S2_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

#define SCORE_BTN joy2Btn(1)
#define UNSCORE_BTN joy2Btn(2)
#define CONVEYOR_IN_BTN joy2Btn(3)
#define CONVEYOR_OUT_BTN joy2Btn(4)
#define SLOW_ROTATE_CW_BTN joy1Btn(6) // cw means clockwise, ccw means counter-clockwise
#define SLOW_ROTATE_CCW_BTN joy1Btn(5)
#define FAST_ROTATE_CW_BTN joy1Btn(8)
#define FAST_ROTATE_CCW_BTN joy1Btn(7)
#define FLAGGER_OUT_BTN joy2Btn(6)
#define FLAGGER_IN_BTN joy2Btn(5)
#define SPIN_FLAGGER_CW_BTN joy2Btn(8)
#define SPIN_FLAGGER_CCW_BTN joy2Btn(7)
#define CATCH_BTN joy2Btn(9)
#define RELEASE_BTN joy2Btn(10)
#define DRIVE_JS_X joystick.joy1_x1
#define DRIVE_JS_Y joystick.joy1_y1
#define DRIVE_DPAD joystick.joy1_TopHat
#define ROTATE_JS joystick.joy1_x2
#define BUCKET_JS joystick.joy2_y1
#define BUCKET_DPAD joystick.joy2_TopHat
#define BUCKET_SERVO (ServoValue[servo1] = n + 5)
#define n Servo[servo1]
#define SLOW_SPEED 20
#define FAST_SPEED 70
#define RESET_SPEED -10
#define SCORE_OFFSET 15
#define SCORE_SPEED 15
#define CONVEYOR_SPEED 100

void InitializeRobot ()
{
	nMotorEncoder[motorLB] = 0;
	nMotorEncoder[motorRB] = 0;
	return;
}

task main(){
	InitializeRobot();
	int conveyor_status = 0;
	waitForStart();
	while(true) {
	  //joystick drive
	  writeDebugStream("%d",((70.7*DRIVE_JS_X)/127.0-(70.7*DRIVE_JS_Y)/127.0));
	  int FRpower = (70.7*DRIVE_JS_X)/127.0-(70.7*DRIVE_JS_Y)/127.0 + (100*ROTATE_JS)/127;
	  int FLpower = (70.7*DRIVE_JS_Y)/127.0+(70.7*DRIVE_JS_X)/127.0 + (100*ROTATE_JS)/127;
	  int BRpower = (70.7*DRIVE_JS_Y)/127.0+(70.7*DRIVE_JS_X)/127.0 - (100*ROTATE_JS)/127;
	  int BLpower = (70.7*DRIVE_JS_X)/127.0-(70.7*DRIVE_JS_Y)/127.0 - (100*ROTATE_JS)/127;

	  if (abs(FRpower) < 10) {
	    FRpower = 0;
	  }
	  if (abs(FLpower) < 10) {
	    FLpower = 0;
	  }if (abs(BRpower) < 10) {
	    BRpower = 0;
	  }if (abs(BLpower) < 10) {
	    BLpower = 0;
	  }
	  motor[motorFR] = FRpower;
	  motor[motorFL] = FLpower;
	  motor[motorBR] = BRpower;
	  motor[motorBL] = BLpower;

		//slow dpad drive
	  
		switch(DRIVE_DPAD) {
		case -1: //not pressed
			break;
		case 0: //forward
			motor[motorFR] = SLOW_SPEED; // we may have to tweak these to get consistent speed
			motor[motorFL] = SLOW_SPEED;
			motor[motorBR] = SLOW_SPEED;
			motor[motorBL] = SLOW_SPEED;
			wait1Msec(20);
			break;
		case 1: //forward-right
			motor[motorFR] = 0;
			motor[motorFL] = SLOW_SPEED;
			motor[motorBR] = SLOW_SPEED;
			motor[motorBL] = 0;
			wait1Msec(20);
			break;
		case 2: //right
			motor[motorFR] = -SLOW_SPEED;
			motor[motorFL] = SLOW_SPEED;
			motor[motorBR] = SLOW_SPEED;
			motor[motorBL] = -SLOW_SPEED;
			wait1Msec(20);
			break;
		case 3: // back-right
			motor[motorFR] = -SLOW_SPEED;
			motor[motorFL] = 0;
			motor[motorBR] = 0;
			motor[motorBL] = -SLOW_SPEED;
			wait1Msec(20);
			break;
		case 4: // backward
			motor[motorFR] = -SLOW_SPEED;
			motor[motorFL] = -SLOW_SPEED;
			motor[motorBR] = -SLOW_SPEED;
			motor[motorBL] = -SLOW_SPEED;
			wait1Msec(20);
			break;
		case 5: //back-left
			motor[motorFR] = 0;
			motor[motorFL] = -SLOW_SPEED;
			motor[motorBR] = -SLOW_SPEED;
			motor[motorBL] = 0;
			wait1Msec(20);
			break;
		case 6: // left
			motor[motorFR] = SLOW_SPEED;
			motor[motorFL] = -SLOW_SPEED;
			motor[motorBR] = -SLOW_SPEED;
			motor[motorBL] = SLOW_SPEED;
			wait1Msec(20);
			break;
		case 7: //forward-left
			motor[motorFR] = SLOW_SPEED;
			motor[motorFL] = 0;
			motor[motorBR] = 0;
			motor[motorBL] = SLOW_SPEED;
			wait1Msec(20);
			break;
		}

		//joystick rotate (only uses x value)
		/**
		motor[motorFR] = -(100*ROTATE_JS)/127;
		motor[motorFL] = (100*ROTATE_JS)/127;
		motor[motorBR] = -(100*ROTATE_JS)/127;
		motor[motorBL] = (100*ROTATE_JS)/127;
		**/
		//slow trigger rotate
		/**
		if(SLOW_ROTATE_CW_BTN){
			motor[motorFR] = -SLOW_SPEED;
			motor[motorFL] = SLOW_SPEED;
			motor[motorBR] = -SLOW_SPEED;
			motor[motorBL] = SLOW_SPEED;
		}
		if(SLOW_ROTATE_CCW_BTN) {
			motor[motorFR] = SLOW_SPEED;
			motor[motorFL] = -SLOW_SPEED;
			motor[motorBR] = SLOW_SPEED;
			motor[motorBL] = -SLOW_SPEED;
		}
		if(FAST_ROTATE_CW_BTN){
			//fast trigger rotate
			motor[motorFR] = -FAST_SPEED;
			motor[motorFL] = FAST_SPEED;
			motor[motorBR] = -FAST_SPEED;
			motor[motorBL] = FAST_SPEED;
		}
		if(FAST_ROTATE_CCW_BTN) {
			motor[motorFR] = FAST_SPEED;
			motor[motorFL] = -FAST_SPEED;
			motor[motorBR] = FAST_SPEED;
			motor[motorBL] = -FAST_SPEED;
		}
		**/
		// joystick bucket control (fast)
		motor[motorLB] = (50*BUCKET_JS)/127;
		motor[motorRB] = (50*BUCKET_JS)/127;
		//dpad bucket control (slow)


		// score/reset , only moves left slider, unscore also resets bucket height
		/**
		if (SCORE_BTN) {
		while ((nMotorEncoder[motorRB] - nMotorEncoder[motorLB]) < SCORE_OFFSET) {
		motor[motorLB] = SCORE_SPEED;
		}
		motor[motorLB] = 0;
		}
		
		while(SCORE_BTN){
			motor[motorLB] = SCORE_SPEED;
		}
		motor[motorLB] = 0;
		if(UNSCORE_BTN) {
			while (nMotorEncoder[motorLB] > nMotorEncoder[motorRB]) 
			{ // resets left slider
				motor[motorRB] = RESET_SPEED;
			}
			int height = nMotorEncoder[motorLB];
			nMotorEncoder[motorLB] = 0;
			while (nMotorEncoder[motorLB] > -height) 
			{ // brings both sliders down
				motor[motorLB] = RESET_SPEED;
				motor[motorRB] = RESET_SPEED;
			}
			motor[motorLB] = 0;
			motor[motorRB] = 0;
			nMotorEncoder[motorLB] = 0;
			nMotorEncoder[motorRB] = 0;
		}
		**/
		//conveyor belt control
		if(CONVEYOR_IN_BTN) {
		  if (conveyor_status == 1) {
		    conveyor_status = 0;
		  }
		  else {
		    conveyor_status = 1;
		  }
		}

		if(CONVEYOR_OUT_BTN) {
		  if (conveyor_status == -1)	{
		    conveyor_status = 0;
		  }
		  else {
		    conveyor_status = -1;
		  }
		}
		motor[motorBELT] = conveyor_status * CONVEYOR_SPEED;

		//flagger in/out

		//spin flagger (Here's an attempt at it)
		while (FLAGGER_OUT_BTN) {
			servo[servo1] = 5;


		}

		while (FLAGGER_IN_BTN) {
			servo[servo1] = 20;
		}
		while (SPIN_FLAGGER_CW_BTN) {
			motor[leggomyeggo] = 30;
		}


	}
}
