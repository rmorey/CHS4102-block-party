#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorC,          leggomyeggo,   tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorBR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorBL,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     motorFL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_2,     motorFR,       tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     motorBELT,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C2_2,     NOTHING,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C4_1,     motorLB,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C4_2,     motorRB,       tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C3_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S2_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

#define SCORE_BTN joy2Btn(1)
#define UNSCORE_BTN joy2Btn(2)
#define CONVEYOR_IN_BTN joy2Btn(3)
#define CONVEYOR_OUT_BTN joy2Btn(4)
#define SLOW_ROTATE_CW_BTN joy1Btn(6) // cw means clockwise, ccw means counter-clockwise
#define SLOW_ROTATE_CCW_BTN joy1Btn(5)
#define FAST_ROTATE_CW_BTN joy1Btn(8)
#define FAST_ROTATE_CCW_BTN joy1Btn(7)
#define FLAGGER_OUT_BTN joy2Btn(6)
#define FLAGGER_IN_BTN joy2Btn(5)
#define SPIN_FLAGGER_CW_BTN joy2Btn(8)
#define SPIN_FLAGGER_CCW_BTN joy2Btn(7)
#define CATCH_BTN joy2Btn(9)
#define RELEASE_BTN joy2Btn(10)
#define DRIVE_JS_X joystick.joy1_x1
#define DRIVE_JS_Y joystick.joy1_y1
#define DRIVE_DPAD joystick.joy1_TopHat
#define ROTATE_JS joystick.joy1_x2
#define BUCKET_JS joystick.joy2_y1
#define BUCKET_DPAD joystick.joy2_TopHat
#define BUCKET_SERVO (ServoValue[servo1] = n + 5)
#define n Servo[servo1]
#define SLOW_SPEED 20
#define FAST_SPEED 70
#define RESET_SPEED -10
#define SCORE_OFFSET 15
#define SCORE_SPEED 15
#define CONVEYOR_SPEED 100

void InitializeRobot (){
	nMotorEncoder[motorLB] = 0;
	nMotorEncoder[motorRB] = 0;
	return;
}

task main(){
	InitializeRobot();
	int conveyor_status = 0;
	waitForStart();
	motor[motorBELT] = 100;
	wait1Msec(30000);
	while(false) {
		//joystick drive
		writeDebugStream("%d",((70.7*DRIVE_JS_X)/127.0-(70.7*DRIVE_JS_Y)/127.0));
		
		motor[motorFR] = (70.7*DRIVE_JS_X)/127.0-(70.7*DRIVE_JS_Y)/127.0 - (100*ROTATE_JS)/127;
		motor[motorFL] = (70.7*DRIVE_JS_Y)/127.0+(70.7*DRIVE_JS_X)/127.0 + (100*ROTATE_JS)/127;
		motor[motorBR] = (70.7*DRIVE_JS_Y)/127.0+(70.7*DRIVE_JS_X)/127.0 - (100*ROTATE_JS)/127;
		motor[motorBL] = (70.7*DRIVE_JS_X)/127.0-(70.7*DRIVE_JS_Y)/127.0 + (100*ROTATE_JS)/127;

		//slow dpad drive
		switch(DRIVE_DPAD) {
		case -1: //not pressed
			break;
		case 0: //forward
			motor[motorFR] = SLOW_SPEED; // we may have to tweak these to get consistent speed
			motor[motorFL] = SLOW_SPEED;
			motor[motorBR] = SLOW_SPEED;
			motor[motorBL] = SLOW_SPEED;
			wait1msec(20);
			break;
		case 1: //forward-right
			motor[motorFR] = 0;
			motor[motorFL] = SLOW_SPEED;
			motor[motorBR] = SLOW_SPEED;
			motor[motorBL] = 0;
			wait1msec(20);
			break;
		case 2: //right
			motor[motorFR] = -SLOW_SPEED;
			motor[motorFL] = SLOW_SPEED;
			motor[motorBR] = SLOW_SPEED;
			motor[motorBL] = -SLOW_SPEED;
			wait1msec(20);
			break;
		case 3: // back-right
			motor[motorFR] = -SLOW_SPEED;
			motor[motorFL] = 0;
			motor[motorBR] = 0;
			motor[motorBL] = -SLOW_SPEED;
			wait1msec(20);
			break;
		case 4: // backward
			motor[motorFR] = -SLOW_SPEED;
			motor[motorFL] = -SLOW_SPEED;
			motor[motorBR] = -SLOW_SPEED;
			motor[motorBL] = -SLOW_SPEED;
			wait1msec(20);
			break;
		case 5: //back-left
			motor[motorFR] = 0;
			motor[motorFL] = -SLOW_SPEED;
			motor[motorBR] = -SLOW_SPEED;
			motor[motorBL] = 0;
			wait1msec(20);
			break;
		case 6: // left
			motor[motorFR] = SLOW_SPEED;
			motor[motorFL] = -SLOW_SPEED;
			motor[motorBR] = -SLOW_SPEED;
			motor[motorBL] = SLOW_SPEED;
			wait1msec(20);
			break;
		case 7: //forward-left
			motor[motorFR] = SLOW_SPEED;
			motor[motorFL] = 0;
			motor[motorBR] = 0;
			motor[motorBL] = SLOW_SPEED;
			wait1msec(20);
			break;
		}

		//joystick rotate (only uses x value)
		/**
		motor[motorFR] = -(100*ROTATE_JS)/127;
		motor[motorFL] = (100*ROTATE_JS)/127;
		motor[motorBR] = -(100*ROTATE_JS)/127;
		motor[motorBL] = (100*ROTATE_JS)/127;
**/
		//slow trigger rotate
		if(SLOW_ROTATE_CW_BTN){
			motor[motorFR] = -SLOW_SPEED;
			motor[motorFL] = SLOW_SPEED;
			motor[motorBR] = -SLOW_SPEED;
			motor[motorBL] = SLOW_SPEED;
		}
		if(SLOW_ROTATE_CCW_BTN) {
			motor[motorFR] = SLOW_SPEED;
			motor[motorFL] = -SLOW_SPEED;
			motor[motorBR] = SLOW_SPEED;
			motor[motorBL] = -SLOW_SPEED;
		}


		//Joystick Slippage
		/**
		if(DRIVE_JS_X < 10)
		{
			DRIVE_JS_X =0;
		}

		if(ROTATE_JS < 10)
		{
			ROTATE_JS = 0;
		}

		if(BUCKET_JS < 10)
		{
			BUCKET_JS = 0;
		}

		if(DRIVE_JS_Y < 10)
		{
			DRIVE_JS_Y = 0;
		}
**/



		if(FAST_ROTATE_CW_BTN){
		//fast trigger rotate
			motor[motorFR] = -FAST_SPEED;
			motor[motorFL] = FAST_SPEED;
			motor[motorBR] = -FAST_SPEED;
			motor[motorBL] = FAST_SPEED;
		}
		if(FAST_ROTATE_CCW_BTN) {
			motor[motorFR] = FAST_SPEED;
			motor[motorFL] = -FAST_SPEED;
			motor[motorBR] = FAST_SPEED;
			motor[motorBL] = -FAST_SPEED;
		}

		// joystick bucket control (fast)
		motor[motorLB] = (100*BUCKET_JS)/127;
		motor[motorRB] = (100*BUCKET_JS)/127;
		// dpad bucket control (slow)


		// score/reset , only moves left slider, unscore also resets bucket height
		if (SCORE_BTN) {
			while ((nMotorEncoder[motorRB] - nMotorEncoder[motorLB]) < SCORE_OFFSET) {
				motor[motorLB] = SCORE_SPEED;
			}
			motor[motorLB] = 0;
		}

		if(UNSCORE_BTN) {
			while (nMotorEncoder[motorLB] > nMotorEncoder[motorRB]) { // resets left slider
				motor[motorRB] = RESET_SPEED;
			}
			int height = nMotorEncoder[motorLB];
			nMotorEncoder[motorLB] = 0;
			while (nMotorEncoder[motorLB] > -height) { // brings both sliders down
				motor[motorLB] = RESET_SPEED;
				motor[motorRB] = RESET_SPEED;
			}
			motor[motorLB] = 0;
			motor[motorRB] = 0;
			nMotorEncoder[motorLB] = 0;
			nMotorEncoder[motorRB] = 0;
		}

		//conveyor belt control
		if(CONVEYOR_IN_BTN) {
			if (conveyor_status == 1)	{
				motor[motorC] = 0;
				conveyor_status = 0;
			}

			else {
				motor[motorC] = CONVEYOR_SPEED;
				conveyor_status = 1;
			}
		}

		if(CONVEYOR_OUT_BTN) {
			if (conveyor_status == -1)	{
				motor[motorC] = 0;
				conveyor_status = 0;
			}


			else {
				motor[motorC] = -CONVEYOR_SPEED;
				conveyor_status = -1;
			}
		}

		//flagger in/out

		//spin flagger (Here's an attempt at it)
		if (FLAGGER_OUT_BTN) {
			servo[servo1] = 168;
		}

		if (FLAGGER_IN_BTN) {
			servo[servo1] = 20;
		}
		if (SPIN_FLAGGER_CW_BTN) {
			motor[motorC] = 10;
		}
		else
		{
			motor[motorC] = 0;
		}


	}
}