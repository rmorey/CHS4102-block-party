#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     DriveFL,       tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     DriveBR,       tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     DriveFR,       tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     DriveBL,       tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void textWrite()
{
TFileHandle   hFileHandle;              // will keep track of our file
  TFileIOResult nIOResult;                // will store our IO results
  string        sFileName = "test.txt";   // the name of our file
  int           nFileSize = 100;          // will store our file size

  byte CR = 0x13;   // define CR (carriage return)
  byte LF = 0x10;   // define LF (line feed)

  string        sMessageToWrite = "ROBOTC IO test!";    // we will write this to the file
  string        sMesageToWrite_2 = "A new line!";       // we will also write this to the file on the next line
  char          incommingChar;                          // this will store each char as we read back in from the file
  string        incommingString[5];                     // this will store the final, fully-read strings (with new strings getting put into new indexes
  int           nLineCounter = 0;                       // this will let us know which line we are on when reading and writing (used as the index to 'incommingString[]')

  Delete("test.txt",nIOResult);
  OpenWrite(hFileHandle, nIOResult, sFileName, nFileSize);    // open the file for writing (creates the file if it does not exist)
  WriteText(hFileHandle, nIOResult, sMessageToWrite);         // write 'sMessageToWrite' to the file
  WriteByte(hFileHandle, nIOResult, CR);                      // write 'CR' to the file (carriage return)
  WriteByte(hFileHandle, nIOResult, LF);                      // write 'LF' to the file (line feed)
  WriteText(hFileHandle, nIOResult, sMesageToWrite_2);        // write 'sMesageToWrite_2' to the file
  Close(hFileHandle, nIOResult);                              // close the file (DON'T FORGET THIS STEP!)

  wait1Msec(1000);  // just a wait so we can see the variables updating in the ROBOTC debugger in order (this is not necessary)

  OpenRead(hFileHandle, nIOResult, sFileName, nFileSize);     // open our file 'sFileName' for reading

  for(int i = 0; i < nFileSize; i++)                          // iterate through the file until we've hit the end:
  {
    ReadByte(hFileHandle, nIOResult, incommingChar);            // read in a single byte

    if(incommingChar == CR || incommingChar == LF)              // if the incomming byte is a carriage return or a line feed:
    {
      if(incommingChar == LF)                                     // if it's a line feed:
        nLineCounter++;                                             // increment our index (will now store next char on a 'new line' (a new index into our 'incommingString[]')
    }
    else
    {
      incommingString[nLineCounter] += incommingChar;             // append that byte (char) to the end of our final string, at the right index
    }
  }
  Close(hFileHandle, nIOResult);                              // close our file (DON'T FORGET THIS STEP!)

  for(int i = 1; i <= 5; i++)
  {
    nxtDisplayCenteredTextLine(i, incommingString[i-1]);
  }
}

task main()
{
  ClearTimer(T1);
  int interval = 30;
	TFileHandle values;
	TFileIOResult nIOResult;
	string  txtname = "values.txt";
  int nFileSize = 100;
	OpenWrite(values, nIOResult, txtname, nFileSize);
	//WriteText(values, nIOResult, FLspeed);
	int Tinitial,Tfinal;
	int FLinitial,FLfinal,FLspeed;
	int BRinitial,BRfinal,BRspeed;
	int FRinitial,FRfinal,FRspeed;
	int BLinitial,BLfinal,BLspeed;
	string sFLspeed, sBRspeed, sFRspeed, sBLspeed;
	int power;
	string space = "SPACE";
	bool done=false;

	//loop
	for(power = 10; power<100; power+=10)
	{
		for(int i=0; i<10; i++)
		{
			done=false;


			motor[DriveBL]=power;
			motor[DriveBR]=power;
			motor[DriveFL]=-power;
			motor[DriveFR]=-power;
			wait1Msec(500);

			ClearTimer(T1);
			Tinitial=time1[T1];

			FLinitial=nMotorEncoder[DriveFL];
      BRinitial=nMotorEncoder[DriveBR];
      FRinitial=nMotorEncoder[DriveFR];
      BLinitial=nMotorEncoder[DriveBL];

			while(!done)
			{
				if(time1[T1]>=interval)
				{
						Tfinal=time1[T1];

    				FLfinal=nMotorEncoder[DriveFL];
    				BRfinal=nMotorEncoder[DriveBR];
    				FRfinal=nMotorEncoder[DriveFR];
    				BLfinal=nMotorEncoder[DriveBL];

    				FLspeed = (FLfinal-FLinitial)/(Tfinal-Tinitial);
    				BRspeed = (BRfinal-BRinitial)/(Tfinal-Tinitial);
    				FRspeed = (FRfinal-FRinitial)/(Tfinal-Tinitial);
    				BLspeed = (BLfinal-BLinitial)/(Tfinal-Tinitial);

    				sFLspeed = FLspeed;
    				sBRspeed = BRspeed;
    				sFRspeed = FRspeed;
    				sBLspeed = BLspeed;

    				WriteText(values, nIOResult, sFLspeed);
    				WriteText(values, nIOResult, sFRspeed);
    				WriteText(values, nIOResult, sBLspeed);
    				WriteText(values, nIOResult, sFRspeed);
						WriteText(values, nIOResult, space);
						done=true;
					}
    		}

    	wait1Msec(1000);

  		}
	}
	Close(values, nIOResult);

}
